//------------------------------------------------------------------------------
// Description 
//    
// $Workfile$
// $Revision$
// $Author  $
// $Modtime $
//
//------------------------------------------------------------------------------

#ifndef _MULTIHASHMAP_H_
#define _MULTIHASHMAP_H_

//Includes
#include <base.h>
#include <memory.h>  // for memset

#ifdef __BORLANDC__
#pragma option -a4
#endif
#ifdef _MSC_VER
#pragma pack(push,4)
#endif

// Template class for mapping keys to values.  Not very complete, and does not
//  hide much information.

template<class Key, class Value>
class MultiHashMap {
   // User must supply a hash function to the cache...
   //
  public:
   typedef UInt16 (*cHashFunc)(const Key& in_key);

   struct pair_type {
      Key   key;
      Value value;
   };
   struct entry_type {
      pair_type   pair;
      entry_type* pNext;
   };

   class iterator {
      friend class MultiHashMap<Key, Value>;
      
      entry_type* pEntry;
      Key         myKey;
      
      iterator(const Key& in_key, entry_type* in_pEntry)
		 : myKey(in_key),
		   pEntry(in_pEntry)
		{}

     public:
      bool isDone() const
		{
		   if (pEntry == NULL ||
		       pEntry->pair.key != myKey)
		      return true;
		   
		   return false;
		}

      void operator++()    // prefix and postfix increments
		{
		   AssertFatal(pEntry != NULL, "bogus");
		   AssertWarn(pEntry->pair.key == myKey, "Warning, possible misuse of iterator");
		   
		   pEntry = pEntry->pNext;
		}
      void operator++(int) { operator++(); }
      
      Value& operator*()             { return pEntry->pair.value; }
      const Value& operator*() const { return pEntry->pair.value; }
   };
   
   MultiHashMap(cHashFunc    in_hashFunction,
                           const UInt32 in_size);
   ~MultiHashMap();
   
   void insert(const Key&   in_key,
                       const Value& in_value);
   bool remove(const Key&   in_key,
                       const Value& in_value);
   iterator find(const Key& in_findKey);
   iterator find(const Key&   in_findKey,
                         const Value& in_findValue);
   void clear();
   bool isFull(void) {  return( m_freeList.pNext == NULL );   }
   
   
  private:
   entry_type* getFreeEntry();
   void releaseEntry(entry_type* in_release);
   
   UInt32    m_size;
   cHashFunc m_hashFunction;

   entry_type* m_pEntries;
   entry_type  m_freeList;
   entry_type* m_pSentries;

   int HashedCache(); // _must_ pass a hash function to the constructor...
};

template<class Key, class Value>
MultiHashMap<Key, Value>::MultiHashMap(cHashFunc    in_hashFunction,
                                       const UInt32 in_size)
 : m_size(in_size),
   m_hashFunction(in_hashFunction)
{
   // For now, hard coded hash range.  Maybe make part of the template?
   //
   m_pSentries = new entry_type[256];
   m_pEntries  = new entry_type[in_size];
   
   clear();
}

template<class Key, class Value>
MultiHashMap<Key, Value>::~MultiHashMap()
{
   delete [] m_pEntries;
   delete [] m_pSentries;
   
   m_pEntries     =
      m_pSentries = NULL;
}

template<class Key, class Value>
void 
MultiHashMap<Key, Value>::clear()
{
   memset(m_pSentries, 0, sizeof(entry_type) * 256);
   memset(m_pEntries,  0, sizeof(entry_type) * m_size);
   
   // for (UInt32 i = 0; i < m_size - 1; i++)
   //    m_pEntries[i].pNext = &m_pEntries[i+1];
   
   // Try it without dereference math.  (This did reduce the assembly
   //    generated by over half actually, in the debug version).
   register    entry_type  *  thisEntry = &m_pEntries[ 0 ];
   register    int            N = m_size - 1;
   while( --N >= 0 )
      thisEntry = (thisEntry->pNext = thisEntry + 1);
   
   m_freeList.pNext = m_pEntries;
}

template<class Key, class Value>
inline typename MultiHashMap<Key, Value>::entry_type* 
MultiHashMap<Key, Value>::getFreeEntry()
{
   AssertFatal(m_freeList.pNext != NULL,
               "Out of hash entries, increase size @ construction");

   entry_type* pRet = m_freeList.pNext;
   m_freeList.pNext = pRet->pNext;
   pRet->pNext = NULL;

   return pRet;
}

template<class Key, class Value>
inline void 
MultiHashMap<Key, Value>::releaseEntry(entry_type* in_pRelease)
{
   AssertFatal(in_pRelease->pNext == NULL, "Error, still refers to something");
   
   in_pRelease->pNext = m_freeList.pNext;
   m_freeList.pNext   = in_pRelease;
}


template<class Key, class Value>
typename MultiHashMap<Key, Value>::iterator 
MultiHashMap<Key, Value>::find(const Key& in_findKey)
{
   UInt16 rawKey = m_hashFunction(in_findKey);
   UInt8  finKey = UInt8((rawKey >> 8) ^ rawKey);
   
   entry_type* pSearch = m_pSentries[finKey].pNext;
   while (pSearch != NULL &&
          pSearch->pair.key != in_findKey) {
      pSearch = pSearch->pNext;
   }
   
   if (pSearch != NULL) {
      return iterator(in_findKey, pSearch);
   } else {
      // try to construct an impossible key.  This should always cause isDone
      //  to return true so long as all the senties keys are set to zero
      //
      Key impossible;
      memset(&impossible, 0xff, sizeof(Key));
      return iterator(impossible, &m_pSentries[finKey]);
   }
}

template<class Key, class Value>
typename MultiHashMap<Key, Value>::iterator 
MultiHashMap<Key, Value>::find(const Key&   in_findKey,
                               const Value& in_findValue)
{
   UInt16 rawKey = m_hashFunction(in_findKey);
   UInt8  finKey = UInt8((rawKey >> 8) ^ rawKey);
   
   entry_type* pSearch = m_pSentries[finKey].pNext;
   while (pSearch != NULL &&
          (pSearch->pair.key   != in_findKey ||
           pSearch->pair.value != in_findValue)) {
      pSearch = pSearch->pNext;
   }

   if (pSearch != NULL) {
      return iterator(in_findKey, pSearch);
   } else {
      // try to construct an impossible key.  This should always cause isDone
      //  to return true so long as all the senties keys are set to zero
      //
      Key impossible;
      memset(&impossible, 0xff, sizeof(Key));
      return iterator(impossible, &m_pSentries[finKey]);
   }
}

template<class Key, class Value>
void 
MultiHashMap<Key, Value>::insert(const Key&   in_key,
                                 const Value& in_value)
{
   iterator insertPoint = find(in_key);
   entry_type* pInsert  = getFreeEntry();
   
   pInsert->pair.key   = in_key;
   pInsert->pair.value = in_value;

   pInsert->pNext = insertPoint.pEntry->pNext;
   insertPoint.pEntry->pNext = pInsert;
}


template<class Key, class Value>
bool 
MultiHashMap<Key, Value>::remove(const Key&   in_key,
                                 const Value& in_value)
{
   // Manually search the lists, since iterators cannot move backwards...
   //
   UInt16 rawKey = m_hashFunction(in_key);
   UInt8  finKey = UInt8((rawKey >> 8) ^ rawKey);
   
   entry_type* pSearch = &m_pSentries[finKey];
   while (pSearch->pNext != NULL &&
          (pSearch->pNext->pair.key   != in_key ||
           pSearch->pNext->pair.value != in_value)) {
      pSearch = pSearch->pNext;
   }

   if (pSearch->pNext != NULL) {
      entry_type* pTemp = pSearch->pNext;
      pSearch->pNext = pTemp->pNext;
      pTemp->pNext = NULL;
      releaseEntry(pTemp);
      return true;
   } else {
      // key doesn't exist in the map...
      //
      return false;
   }
}

#ifdef __BORLANDC__
#pragma option -a.
#endif
#ifdef _MSC_VER
#pragma pack(pop)
#endif

#endif //_MULTIHASHMAP_H_
